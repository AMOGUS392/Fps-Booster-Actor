local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local character
local humanoid_root_part

local function updateCharacter(char)
    character = char
    humanoid_root_part = char:WaitForChild("HumanoidRootPart")
end

if player.Character then
    updateCharacter(player.Character)
else
    updateCharacter(player.CharacterAdded:Wait())
end

player.CharacterAdded:Connect(updateCharacter)

local cleanup_distance = 500
local cleanup_interval = 5
local max_actors = 2

if not checkparallel() then
    return
end

local function heavy_cleanup_task(actor)
    actor:SetAttribute("CleanupDistance", cleanup_distance)
    actor:SetAttribute("CleanupInterval", cleanup_interval)
    
    task.desynchronize()
    
    while true do
        local char = player.Character
        if not char then
            task.wait(1)
            continue
        end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            task.wait(1)
            continue
        end
        
        local player_pos = hrp.Position
        local to_clean = {}
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj:IsA("BasePart") and not char:IsAncestorOf(obj) then
                local dist = (obj.Position - player_pos).Magnitude
                if dist > actor:GetAttribute("CleanupDistance") then
                    table.insert(to_clean, obj)
                end
            end
        end
        
        task.synchronize()
        for _, obj in to_clean do
            obj.Transparency = 1
            obj.CanCollide = false
        end
        task.wait(actor:GetAttribute("CleanupInterval"))
        
        task.desynchronize()
    end
end

local function setup_optimization()
    local active_actors = getactors() or {}
    local opt_actors = {}
    for _, actor in pairs(active_actors) do
        if string.find(actor.Name, "optimization_actor_") then
            table.insert(opt_actors, actor)
        end
    end
    local needed_actors = math.max(0, max_actors - #opt_actors)
    
    for i = 1, needed_actors do
        local new_actor = Instance.new("Actor")
        new_actor.Name = "optimization_actor_" .. (#opt_actors + i)
        new_actor.Parent = Workspace
        
        run_on_actor(new_actor, heavy_cleanup_task, new_actor)
    end
    
    local channel = create_comm_channel("opt_channel")
end

if checkparallel() then
    setup_optimization()
else
    spawn(setup_optimization)
end

spawn(function()
    while task.wait(1) do
        local actors = getactors() or {}
        local to_destroy = {}
        for _, actor in pairs(actors) do
            if string.find(actor.Name, "optimization_actor_") then
                local threads = getactorthreads(actor)
                if #threads == 0 then
                    table.insert(to_destroy, actor)
                end
            end
        end
        for _, actor in pairs(to_destroy) do
            actor:Destroy()
        end
        actors = getactors() or {}
        local opt_actors = {}
        for _, actor in pairs(actors) do
            if string.find(actor.Name, "optimization_actor_") then
                table.insert(opt_actors, actor)
            end
        end
        if #opt_actors == 0 then
            setup_optimization()
        end
    end
end)
